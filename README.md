Алгоритмы сортировки
1. Сортировка выбором (Selection Sort)
Определение:
Алгоритм, который на каждом шаге находит минимальный элемент в неотсортированной части массива и меняет его местами с первым элементом этой части.

Анализ:

Внешний цикл проходит по всем элементам массива (n итераций)

Внутренний цикл ищет минимальный элемент в оставшейся части

Количество сравнений: (n-1) + (n-2) + ... + 1 = n(n-1)/2

Количество обменов: n-1 (по одному на каждую итерацию)

Временная сложность: O(n²)

Почему O(n²): Два вложенных цикла, каждый из которых зависит от n. В худшем, среднем и лучшем случае выполняется O(n²) операций.

2. Сортировка пузырьком (Bubble Sort)
Определение:
Алгоритм, который многократно проходит по массиву, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке.

Анализ:

Внешний цикл выполняется n-1 раз

Внутренний цикл на каждой итерации проходит по уменьшающейся части массива

В худшем случае выполняется n(n-1)/2 сравнений и обменов

В лучшем случае (уже отсортированный массив) - O(n) сравнений

Временная сложность: O(n²)

Почему O(n²): Два вложенных цикла, где внутренний цикл в худшем случае выполняется n раз для каждого из n проходов.

3. Сортировка вставками (Insertion Sort)
Определение:
Алгоритм строит отсортированную часть массива, вставляя каждый новый элемент в правильную позицию среди уже отсортированных элементов.

Анализ:

Внешний цикл проходит по всем элементам (n итераций)

Внутренний цикл в худшем случае сдвигает элементы от текущей позиции до начала массива

В худшем случае: n(n-1)/2 сравнений и обменов

В лучшем случае: O(n) сравнений (уже отсортированный массив)

Временная сложность: O(n²)

Почему O(n²): В худшем случае два вложенных цикла выполняются пропорционально n² раз. Эффективен для небольших или частично отсортированных массивов.

4. Сортировка слиянием (Merge Sort)
Определение:
Алгоритм "разделяй и властвуй", который рекурсивно делит массив пополам, сортирует каждую половину и затем сливает их в отсортированный массив.

Анализ:

Рекурсивно делит массив пополам (log n уровней деления)

На каждом уровне выполняет O(n) операций при слиянии

Всегда требует O(n) дополнительной памяти

Количество операций не зависит от исходного порядка элементов

Временная сложность: O(n log n)

Почему O(n log n): Глубина рекурсии - O(log n), на каждом уровне выполняется O(n) операций слияния.

5. Сортировка Шелла (Shell Sort)
Определение:
Улучшенная версия сортировки вставками, которая сортирует элементы, отстоящие друг от друга на некотором расстоянии (gap), постепенно уменьшая это расстояние.

Анализ:

Использует последовательность промежутков (gaps)

Начинает с большого gap, постепенно уменьшает до 1

Эффективность зависит от выбора последовательности gaps

В худшем случае: O(n²), но на практике часто O(n^(3/2))

Временная сложность: O(n²) (в худшем случае)

Почему O(n²): При неудачной последовательности gaps может вырождаться до O(n²), но обычно работает лучше чем O(n²).

6. Быстрая сортировка (Quick Sort)
Определение:
Алгоритм "разделяй и властвуй", который выбирает опорный элемент и перераспределяет другие элементы относительно него.

Анализ:

В среднем случае: O(n log n)

В худшем случае: O(n²) при неудачном выборе опорного элемента

Глубина рекурсии: O(log n) в среднем, O(n) в худшем случае

In-place алгоритм (не требует дополнительной памяти)

Временная сложность: O(n log n) (средний случай)

Почему O(n log n): В среднем случае массив делится пополам на каждом уровне рекурсии, что дает O(log n) уровней с O(n) операциями на каждом.

7. Пирамидальная сортировка (Heap Sort)
Определение:
Алгоритм, который строит из массива двоичную кучу и последовательно извлекает максимальный элемент, помещая его в конец массива.

Анализ:

Построение кучи: O(n) операций

Извлечение каждого элемента: O(log n) операций

Всего n извлечений: O(n log n)

In-place алгоритм, не требует дополнительной памяти

Временная сложность: O(n log n)

Почему O(n log n): Построение кучи O(n) + n извлечений по O(log n) каждое = O(n log n).

Алгоритмы поиска
8. Линейный поиск (Linear Search)
Определение:
Последовательная проверка каждого элемента массива до тех пор, пока не будет найден искомый элемент.

Анализ:

В худшем случае: проверяет все n элементов

В лучшем случае: находит элемент на первой позиции

В среднем случае: проверяет n/2 элементов

Работает с неотсортированными массивами

Временная сложность: O(n)

Почему O(n): В худшем случае требуется проверить все n элементов массива.

9. Бинарный поиск (Binary Search)
Определение:
Алгоритм поиска в отсортированном массиве, который на каждом шаге делит область поиска пополам.

Анализ:

На каждом шаге область поиска уменьшается вдвое

Максимальное количество шагов: log₂(n)

Требует предварительной сортировки массива

Работает только с отсортированными данными

Временная сложность: O(log n)

Почему O(log n): На каждом шаге размер области поиска уменьшается в 2 раза, что дает логарифмическую сложность.

10. Интерполяционный поиск (Interpolation Search)
Определение:
Улучшенная версия бинарного поиска, которая предсказывает позицию искомого элемента на основе значений элементов.

Анализ:

В лучшем случае: O(log log n) при равномерном распределении

В худшем случае: O(n) при неравномерном распределении

Использует формулу интерполяции для предсказания позиции

Эффективен для равномерно распределенных данных

Временная сложность: O(log log n) (в лучшем случае)

Почему O(log log n): При равномерном распределении данных область поиска сокращается быстрее чем в бинарном поиске.

11. Поиск Фибоначчи (Fibonacci Search)
Определение:
Алгоритм поиска, использующий числа Фибоначчи для определения позиций сравнения.

Анализ:

Аналогичен бинарному поиску по сложности

Использует деление на основе чисел Фибоначчи

Избегает деления (полезно на системах где деление дорого)

Требует предварительного вычисления чисел Фибоначчи

Временная сложность: O(log n)

Почему O(log n): Как и бинарный поиск, уменьшает область поиска в константное число раз на каждом шаге.
