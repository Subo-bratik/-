Алгоритмы сортировки
1. Сортировка выбором (Selection Sort)
Работа алгоритма:

Внешний цикл проходит по всем элементам кроме последнего

Внутренний цикл ищет минимальный элемент в неотсортированной части

После нахождения минимального элемента происходит обмен

Временная сложность: O(n²)
Два вложенных цикла выполняют n(n-1)/2 сравнений и n-1 обменов, что дает квадратичную зависимость.

2. Сортировка пузырьком (Bubble Sort)
Работа алгоритма:

Внешний цикл делает n-1 проходов по массиву

Внутренний цикл сравнивает соседние элементы и меняет их при необходимости

После каждого прохода самый большой элемент оказывается в конце

Временная сложность: O(n²)
Два вложенных цикла выполняют до n(n-1)/2 сравнений и обменов в худшем случае.

3. Сортировка вставками (Insertion Sort)
Работа алгоритма:

Начинает со второго элемента и вставляет каждый следующий в правильную позицию

Сдвигает элементы больше текущего вправо

Вставляет элемент на освободившееся место

Временная сложность: O(n²)
Для каждого из n элементов может потребоваться до n сдвигов, что дает квадратичную сложность.

4. Сортировка слиянием (Merge Sort)
Работа алгоритма:

Рекурсивно делит массив пополам до отдельных элементов

Сливает отсортированные половины в отсортированный массив

При слиянии сравнивает элементы из двух половин

Временная сложность: O(n log n)
Массив делится на log n уровней, на каждом уровне выполняется O(n) операций слияния.

5. Сортировка Шелла (Shell Sort)
Работа алгоритма:

Сортирует элементы на определенном расстоянии друг от друга

Постепенно уменьшает расстояние до 1

На последнем шаге выполняет обычную сортировку вставками

Временная сложность: O(n²)
При неудачной последовательности промежутков может вырождаться до квадратичной сложности.

6. Быстрая сортировка (Quick Sort)
Работа алгоритма:

Выбирает опорный элемент и перераспределяет элементы относительно него

Рекурсивно сортирует левую и правую части

Использует стратегию "разделяй и властвуй"

Временная сложность: O(n log n)
При сбалансированном разбиении глубина рекурсии log n с O(n) операциями на каждом уровне.

7. Пирамидальная сортировка (Heap Sort)
Работа алгоритма:

Строит двоичную кучу из массива

Последовательно извлекает максимальный элемент из кучи

Перестраивает кучу после каждого извлечения

Временная сложность: O(n log n)
Построение кучи O(n) + n извлечений по O(log n) каждое = O(n log n).

Алгоритмы поиска
8. Линейный поиск (Linear Search)
Работа алгоритма:

Последовательно проверяет каждый элемент массива

Возвращает индекс при нахождении элемента

Возвращает -1 если элемент не найден

Временная сложность: O(n)
В худшем случае требуется проверить все n элементов массива.

9. Бинарный поиск (Binary Search)
Работа алгоритма:

Работает только с отсортированными массивами

На каждом шаге делит область поиска пополам

Сравнивает искомый элемент с серединой текущей области

Временная сложность: O(log n)
На каждом шаге область поиска уменьшается вдвое, требуется log₂n шагов.

10. Интерполяционный поиск
Работа алгоритма:

Предсказывает позицию элемента на основе значений

Использует интерполяционную формулу для вычисления позиции

Работает с равномерно распределенными данными

Временная сложность: O(log log n)
При равномерном распределении данных область поиска сокращается быстрее чем в бинарном поиске.

11. Поиск Фибоначчи
Работа алгоритма:

Использует числа Фибоначчи для определения позиций сравнения

Делит массив в золотом сечении вместо пополам

Избегает операции деления

Временная сложность: O(log n)
Аналогичен бинарному поиску по асимптотической сложности, но с другими константами.
